---
phase: 01-foundation-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - JunkOS-Clean/JunkOS/Utilities/KeychainHelper.swift
  - JunkOS-Clean/JunkOS/Managers/AuthenticationManager.swift
  - JunkOS-Clean/JunkOS/Services/APIClient.swift
  - JunkOS-Clean/JunkOS/Models/APIModels.swift
  - backend/routes/auth_routes.py
autonomous: true

must_haves:
  truths:
    - "Customer app stores JWT tokens in Keychain, not UserDefaults"
    - "Customer app sends nonce with Apple Sign In identity token to backend"
    - "Backend validates Apple identity token signature and nonce before issuing JWT"
    - "Auth token is automatically attached to all authenticated API requests"
    - "User session restores from Keychain on app restart without re-login"
    - "Token refresh happens silently when token is near expiry"
  artifacts:
    - path: "JunkOS-Clean/JunkOS/Utilities/KeychainHelper.swift"
      provides: "Keychain CRUD for JWT tokens"
      contains: "SecItemAdd"
    - path: "JunkOS-Clean/JunkOS/Managers/AuthenticationManager.swift"
      provides: "Apple Sign In with nonce, async/await, Keychain storage"
      contains: "ASAuthorizationAppleIDRequest"
    - path: "JunkOS-Clean/JunkOS/Services/APIClient.swift"
      provides: "Authenticated API requests with JWT from Keychain"
      contains: "KeychainHelper"
    - path: "backend/routes/auth_routes.py"
      provides: "Nonce validation for Apple Sign In"
      contains: "nonce"
  key_links:
    - from: "JunkOS-Clean/JunkOS/Managers/AuthenticationManager.swift"
      to: "JunkOS-Clean/JunkOS/Utilities/KeychainHelper.swift"
      via: "Keychain save/load for JWT"
      pattern: "KeychainHelper\\.save|KeychainHelper\\.loadString"
    - from: "JunkOS-Clean/JunkOS/Services/APIClient.swift"
      to: "JunkOS-Clean/JunkOS/Utilities/KeychainHelper.swift"
      via: "Auth header injection from Keychain"
      pattern: "KeychainHelper\\.loadString.*authToken"
    - from: "JunkOS-Clean/JunkOS/Managers/AuthenticationManager.swift"
      to: "backend/routes/auth_routes.py"
      via: "POST /api/auth/apple with identity_token and nonce"
      pattern: "/api/auth/apple"
---

<objective>
Customer app auth infrastructure: Keychain storage, Apple Sign In with nonce, token refresh, and authenticated networking layer.

Purpose: AUTH-01 (migrate JWT from UserDefaults to Keychain) and AUTH-02 (Apple Sign In with backend nonce validation). This plan creates the secure auth foundation that the customer app's UI layer (Plan 03) will consume.

Output: KeychainHelper, rewritten AuthenticationManager (async/await, nonce, token refresh), APIClient with auth injection, backend nonce validation endpoint.
</objective>

<execution_context>
@/Users/sevs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sevs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-CONTEXT.md

# Existing files to reference
@JunkOS-Clean/JunkOS/Managers/AuthenticationManager.swift
@JunkOS-Clean/JunkOS/Services/APIClient.swift
@JunkOS-Clean/JunkOS/Services/Config.swift
@JunkOS-Clean/JunkOS/Models/APIModels.swift
@JunkOS-Clean/JunkOS/Design/DesignSystem.swift
@JunkOS-Driver/Utilities/KeychainHelper.swift
@backend/routes/auth_routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create customer app KeychainHelper and rewrite AuthenticationManager</name>
  <files>
    JunkOS-Clean/JunkOS/Utilities/KeychainHelper.swift
    JunkOS-Clean/JunkOS/Managers/AuthenticationManager.swift
  </files>
  <action>
**KeychainHelper.swift** — Create a new file modeled after the driver app's KeychainHelper (at `JunkOS-Driver/Utilities/KeychainHelper.swift`). Use service identifier `"com.goumuve.app"` with legacy fallback to `"com.goumuve.customer"` (for future migration safety). Include:
- `save(_ data: Data, forKey:)` and `save(_ string: String, forKey:)` — stores in Keychain with `kSecAttrAccessibleAfterFirstUnlock`
- `load(forKey:) -> Data?` and `loadString(forKey:) -> String?` — reads from Keychain, falls back to legacy service key, migrates if found
- `delete(forKey:)` — removes from both current and legacy service keys

Also add a **one-time migration from UserDefaults**: In `load(forKey:)`, after checking both Keychain services, check `UserDefaults.standard.string(forKey: key)`. If found, migrate it into Keychain and remove from UserDefaults. This handles AUTH-01 migration transparently.

**AuthenticationManager.swift** — Complete rewrite. Change from `ObservableObject` to `@Observable` (Swift Observation framework, matching driver app pattern). Use `async/await` instead of completion handlers. Remove ALL phone auth, email auth, guest mode, and forgot password methods. Keep ONLY:

1. **Properties:** `isAuthenticated: Bool`, `currentUser: User?`, `isLoading: Bool`, `errorMessage: String?`

2. **Apple Sign In with nonce:**
   - `handleAppleSignInRequest(_ request:)` — Generate a random nonce (32 bytes from `SecRandomCopyBytes`, SHA256 hashed). Store raw nonce in a private property `currentNonce`. Set `request.requestedScopes = [.fullName, .email]` and `request.nonce = sha256HashOfNonce`.
   - `handleAppleSignInCompletion(_ result:)` — Extract `ASAuthorizationAppleIDCredential`. Get `credential.identityToken` (Data), decode to String. Send to backend with the raw nonce, email, name.
   - Private `authenticateWithApple(identityToken:nonce:email:name:)` — async POST to `/api/auth/apple` with body: `{ "identity_token": "<jwt>", "nonce": "<raw_nonce>", "email": "...", "name": "..." }`. Decode `AuthResponse` (same shape as driver: `{ success, token, user }`). Call `setAuthenticated(user:token:)`.

3. **Session management:**
   - `init()` — Call `Task { await restoreSession() }`
   - `restoreSession()` — Load token from `KeychainHelper.loadString(forKey: "authToken")`. If found, POST to `/api/auth/validate` with Bearer token. If 200, parse user and set authenticated. If fails, check token hasn't been replaced, then clear.
   - `setAuthenticated(user:token:)` — Save token and userId to Keychain. Set published properties. Call `NotificationManager.shared.reRegisterTokenIfNeeded()`.
   - `refreshTokenIfNeeded()` — Check JWT expiry by decoding the payload (base64 middle segment). If expiring within 24 hours, POST to `/api/auth/refresh` with current Bearer token. On success, save new token to Keychain. On failure, don't logout (keep cached state per user decision about offline launch).
   - `logout()` — Clear Keychain keys `authToken` and `userId`. Reset properties.

4. **Nonce helper (private):**
   - `generateNonce(length: Int = 32) -> String` — Random bytes converted to hex string
   - `sha256(_ input: String) -> String` — SHA256 hash using CryptoKit, return hex string

5. **User model** — Keep the existing `User` struct but make sure it matches: `id: String, name: String?, email: String?, phoneNumber: String?`. Add `role: String?` field. Add `displayName` computed property.

6. **Error handling per user decisions:**
   - Sign-in failure: set `errorMessage = "Something went wrong. Try again."` — stay on sign-in screen
   - Backend down: retry 2-3 times silently with 1-second delay between attempts, then set errorMessage if still failing
   - Role conflict: if backend returns specific error about role conflict, set `errorMessage = "This account is registered as a customer. Contact support to become a driver."` (note: this message would come from backend, but handle the specific error code)

Import `CryptoKit` for SHA256.
  </action>
  <verify>
Build the JunkOS-Clean Xcode project — `xcodebuild build -project JunkOS-Clean/JunkOS-Clean.xcodeproj -scheme JunkOS -destination 'platform=iOS Simulator,name=iPhone 16' -quiet 2>&1 | tail -5`. Should compile without errors. Verify KeychainHelper.swift exists with SecItemAdd/SecItemCopyMatching. Verify AuthenticationManager uses @Observable and has no phone/email/guest methods.
  </verify>
  <done>
KeychainHelper created with save/load/delete/migration. AuthenticationManager rewritten with @Observable, async/await, Apple Sign In with nonce generation (SHA256), session restore from Keychain, token refresh, retry logic. No phone, email, or guest auth methods remain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update APIClient with Keychain auth injection and add backend nonce validation</name>
  <files>
    JunkOS-Clean/JunkOS/Services/APIClient.swift
    JunkOS-Clean/JunkOS/Models/APIModels.swift
    backend/routes/auth_routes.py
  </files>
  <action>
**APIClient.swift** — Update the existing `createRequest` method to automatically inject the JWT auth header from Keychain:
- In `createRequest(endpoint:method:body:)`, after setting Content-Type and X-API-Key headers, add: `if let token = KeychainHelper.loadString(forKey: "authToken") { request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization") }`
- Remove the manual auth token injection in `getReferralCode()` that reads from UserDefaults
- Remove ALL references to `UserDefaults.standard.string(forKey: "authToken")` from the file
- Add a new method: `func validateToken() async throws -> User` that POSTs to `/api/auth/validate` and returns the user
- Add a new method: `func refreshToken() async throws -> AuthRefreshResponse` that POSTs to `/api/auth/refresh` and returns a new token
- Handle 401 responses in `performRequest` by attempting one silent token refresh before throwing unauthorized. If refresh succeeds, retry the original request once.

**APIModels.swift** — Add models needed for auth:
- `AuthResponse` struct: `success: Bool, token: String, user: User` (if not already present — check existing models)
- `AuthRefreshResponse` struct: `success: Bool, token: String`
- `ValidateTokenResponse` struct: `success: Bool, user: User`
- Ensure the existing `APIError` struct used by the decode error path is present (currently named differently in customer vs driver app — use the existing `APIError` name in the customer app)

**backend/routes/auth_routes.py** — Update the `/api/auth/apple` endpoint:
- Accept `identity_token` (the Apple JWT) and `nonce` in the request body (in addition to existing `userIdentifier`, `email`, `name` fields)
- Validate the Apple identity token: decode the JWT header to get the `kid`, fetch Apple's public keys from `https://appleid.apple.com/auth/keys`, verify the JWT signature using the matching key (use `PyJWT` with `jwt.decode()` and `jwt.algorithms.RSAAlgorithm.from_jwk()`). Verify: `iss == "https://appleid.apple.com"`, `aud == bundle_id` (accept both `com.goumuve.app` and `com.goumuve.pro`), token not expired, `nonce` claim matches SHA256 of the provided nonce.
- Cache Apple's public keys for 24 hours (use a module-level variable with timestamp, not Redis — keep it simple for v1)
- If `identity_token` is NOT provided (backward compatibility), fall back to the existing `userIdentifier`-based flow
- Import `jwt` (PyJWT) and `hashlib` at the top
- Return the same response shape: `{ success: true, token: "<jwt>", user: {...} }`

For the backend nonce validation, also add a `/api/auth/refresh` endpoint if it doesn't exist:
- Accept Bearer token in Authorization header
- Decode the existing JWT, verify it's not expired by more than 7 days (grace period for refresh)
- Issue a new JWT with 30-day expiry
- Return `{ success: true, token: "<new_jwt>" }`
  </action>
  <verify>
1. Customer app builds: `xcodebuild build -project JunkOS-Clean/JunkOS-Clean.xcodeproj -scheme JunkOS -destination 'platform=iOS Simulator,name=iPhone 16' -quiet 2>&1 | tail -5`
2. Backend starts: `cd backend && python -c "from routes.auth_routes import *; print('Auth routes import OK')"` (or similar import check)
3. Grep confirms no UserDefaults auth token references in APIClient: `grep -c "UserDefaults" JunkOS-Clean/JunkOS/Services/APIClient.swift` should return 0
4. Grep confirms nonce handling in backend: `grep -c "nonce" backend/routes/auth_routes.py` should return > 0
  </verify>
  <done>
APIClient injects JWT from Keychain on all requests automatically. Token refresh on 401 with one silent retry. Backend /api/auth/apple validates Apple identity token JWT signature and nonce. Backend /api/auth/refresh endpoint issues new 30-day tokens. No UserDefaults references remain in APIClient.
  </done>
</task>

</tasks>

<verification>
1. `grep -r "UserDefaults.*authToken" JunkOS-Clean/` returns 0 matches (all JWT storage migrated to Keychain)
2. `grep "KeychainHelper" JunkOS-Clean/JunkOS/Managers/AuthenticationManager.swift` returns matches (Keychain integration confirmed)
3. `grep "KeychainHelper" JunkOS-Clean/JunkOS/Services/APIClient.swift` returns matches (auth header injection confirmed)
4. `grep "nonce" JunkOS-Clean/JunkOS/Managers/AuthenticationManager.swift` returns matches (nonce generation confirmed)
5. `grep "identity_token" backend/routes/auth_routes.py` returns matches (backend token validation confirmed)
6. `xcodebuild build -project JunkOS-Clean/JunkOS-Clean.xcodeproj -scheme JunkOS -destination 'platform=iOS Simulator,name=iPhone 16' -quiet` succeeds
</verification>

<success_criteria>
- Customer app JWT stored in Keychain, not UserDefaults
- Apple Sign In sends identity_token + nonce to backend
- Backend verifies Apple JWT signature and nonce before issuing session JWT
- All API requests include Bearer token from Keychain automatically
- Token refresh happens silently on 401
- Session restores from Keychain on app restart
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-01-SUMMARY.md`
</output>
