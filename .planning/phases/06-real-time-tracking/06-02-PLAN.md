---
phase: 06-real-time-tracking
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - JunkOS-Clean/JunkOS/Services/Config.swift
  - JunkOS-Clean/JunkOS/Services/CustomerSocketManager.swift
  - JunkOS-Clean/JunkOS/Views/Tracking/JobTrackingView.swift
  - JunkOS-Clean/JunkOS/Managers/NotificationManager.swift
autonomous: true

must_haves:
  truths:
    - "Customer app has a Socket.IO manager that connects to the backend and listens for driver:location events"
    - "Customer app has a map view that displays driver location as a car annotation"
    - "Customer app registers notification categories for all job status transitions"
    - "Socket.IO room join/leave lifecycle is managed correctly (join on appear, leave on disappear)"
  artifacts:
    - path: "JunkOS-Clean/JunkOS/Services/CustomerSocketManager.swift"
      provides: "Socket.IO connection, room join/leave, driver location listening"
      contains: "CustomerSocketManager"
    - path: "JunkOS-Clean/JunkOS/Views/Tracking/JobTrackingView.swift"
      provides: "MapKit view showing driver location as annotation"
      contains: "JobTrackingView"
    - path: "JunkOS-Clean/JunkOS/Services/Config.swift"
      provides: "socketURL property for Socket.IO connection"
      contains: "socketURL"
    - path: "JunkOS-Clean/JunkOS/Managers/NotificationManager.swift"
      provides: "Notification categories for job_en_route, job_arrived, job_started, job_completed"
      contains: "job_arrived"
  key_links:
    - from: "JunkOS-Clean/JunkOS/Views/Tracking/JobTrackingView.swift"
      to: "JunkOS-Clean/JunkOS/Services/CustomerSocketManager.swift"
      via: "joinJobRoom/leaveJobRoom in onAppear/onDisappear"
      pattern: "joinJobRoom|leaveJobRoom"
    - from: "JunkOS-Clean/JunkOS/Services/CustomerSocketManager.swift"
      to: "Config.socketURL"
      via: "Socket.IO connection URL"
      pattern: "socketURL"
---

<objective>
Create customer-side Socket.IO infrastructure and tracking map view for displaying live driver location.

Purpose: TRACK-01 requires the customer to see driver location on a map during active jobs. This plan builds the customer Socket.IO manager (new file), adds socketURL to Config, creates the MapKit tracking view, and registers notification categories for status transitions.

Output: CustomerSocketManager.swift, JobTrackingView.swift with MapKit driver annotation, Config.swift with socketURL, enhanced NotificationManager with all status categories.
</objective>

<execution_context>
@/Users/sevs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sevs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-real-time-tracking/06-RESEARCH.md
@JunkOS-Clean/JunkOS/Services/Config.swift
@JunkOS-Clean/JunkOS/Managers/NotificationManager.swift
@JunkOS-Clean/JunkOS/Models/APIModels.swift
@JunkOS-Clean/JunkOS/Views/OrdersView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add socketURL to Config and create CustomerSocketManager</name>
  <files>
    JunkOS-Clean/JunkOS/Services/Config.swift
    JunkOS-Clean/JunkOS/Services/CustomerSocketManager.swift
  </files>
  <action>
  **Config.swift** — Add `socketURL` property to the customer app's Config:
  1. Add `socketURL` to `APIEnvironment` enum (same pattern as driver app's Config):
     - development: `"http://localhost:8080"`
     - production: `"https://junkos-backend.onrender.com"`
  2. Add `var socketURL: String { environment.socketURL }` to `Config` class

  **CustomerSocketManager.swift** — Create new file in `JunkOS-Clean/JunkOS/Services/`:
  1. Import Foundation and SocketIO
  2. Create `class CustomerSocketManager: ObservableObject` (use ObservableObject, NOT @Observable, for consistency with customer app pattern from Phase 1 decision)
  3. `static let shared = CustomerSocketManager()`
  4. Properties:
     - `private var manager: SocketManager?`
     - `private var socket: SocketIOClient?`
     - `@Published var isConnected = false`
     - `@Published var driverLatitude: Double?`
     - `@Published var driverLongitude: Double?`
  5. `func connect(token: String)`:
     - Use `Config.shared.socketURL` for URL
     - Configure with `.connectParams(["token": token])`, `.forceWebsockets(true)`, `.log(false)`
     - Set up `.connect` and `.disconnect` handlers updating `isConnected`
     - Listen for `"driver:location"` event: parse `lat`/`lng` from data dict, update `driverLatitude`/`driverLongitude` on main thread, post `NotificationCenter.default.post(name: NSNotification.Name("driverLocationUpdated"), object: nil)`
     - Listen for `"job:status"` event: parse `status` from data dict, post `NotificationCenter.default.post(name: NSNotification.Name("jobStatusUpdated"), object: nil, userInfo: data)`
     - Call `socket?.connect()`
  6. `func joinJobRoom(jobId: String)`:
     - `socket?.emit("customer:join", ["job_id": jobId])`
  7. `func leaveJobRoom(jobId: String)`:
     - `socket?.emit("customer:leave", ["job_id": jobId])`
  8. `func disconnect()`:
     - `socket?.disconnect()`, nil out manager/socket, reset published properties

  **Important:** Use `DispatchQueue.main.async` when updating `@Published` properties from Socket.IO callbacks. The customer app uses ObservableObject (not @Observable) per Phase 1 decision.
  </action>
  <verify>
  Verify CustomerSocketManager.swift exists in JunkOS-Clean/JunkOS/Services/ with connect(), joinJobRoom(), leaveJobRoom(), disconnect() methods. Verify Config.swift has socketURL property.
  </verify>
  <done>
  Customer app has CustomerSocketManager that connects via Socket.IO, joins/leaves job rooms, and publishes driver location coordinates via @Published properties and NotificationCenter.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create JobTrackingView and register status notification categories</name>
  <files>
    JunkOS-Clean/JunkOS/Views/Tracking/JobTrackingView.swift
    JunkOS-Clean/JunkOS/Managers/NotificationManager.swift
  </files>
  <action>
  **JobTrackingView.swift** — Create new file in `JunkOS-Clean/JunkOS/Views/Tracking/`:
  1. Import SwiftUI and MapKit
  2. Create `struct DriverAnnotation: Identifiable` with `let id = UUID()` and `var coordinate: CLLocationCoordinate2D`
  3. Create `struct JobTrackingView: View`:
     - Properties:
       - `let jobId: String`
       - `let jobAddress: String` (for display)
       - `let driverName: String?`
       - `@State private var region = MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194), span: MKCoordinateSpan(latitudeDelta: 0.02, longitudeDelta: 0.02))`
       - `@State private var driverAnnotation: DriverAnnotation?`
       - `@State private var hasReceivedFirstLocation = false`
       - `@State private var jobStatus: String = "en_route"`
     - Computed `annotations: [DriverAnnotation]`: return array with driverAnnotation if non-nil, else empty
     - Body:
       - VStack with navigation title "Track Driver"
       - Status banner at top showing current job status (use colored capsule like BookingCard statusBadge)
       - `Map(coordinateRegion: $region, annotationItems: annotations)` with `MapAnnotation` showing ZStack of circle + `Image(systemName: "car.fill")` in `.umuvePrimary` color
       - If `!hasReceivedFirstLocation`: overlay with ProgressView and "Waiting for driver location..."
       - Bottom card showing driver name and job address
     - `.onAppear`:
       - Connect CustomerSocketManager if not connected: `if let token = KeychainHelper.loadString(forKey: "authToken") { CustomerSocketManager.shared.connect(token: token) }`
       - Join job room: `CustomerSocketManager.shared.joinJobRoom(jobId: jobId)`
     - `.onDisappear`:
       - Leave job room: `CustomerSocketManager.shared.leaveJobRoom(jobId: jobId)`
     - `.onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("driverLocationUpdated")))`:
       - Read `CustomerSocketManager.shared.driverLatitude/driverLongitude`
       - Update `driverAnnotation` coordinate
       - If `!hasReceivedFirstLocation`: center map region on driver, set `hasReceivedFirstLocation = true`
     - `.onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("jobStatusUpdated")))`:
       - Parse status from notification userInfo
       - Update `jobStatus`
       - If status is "completed": could show completion message

  4. Add a "Re-center on Driver" button (small FAB in bottom-right) that re-centers the map on the driver's current location when tapped.

  **NotificationManager.swift** — Add status-specific notification categories:
  1. Add new cases to `NotificationCategory` enum:
     - `case jobArrived = "job_arrived"`
     - `case jobStarted = "job_started"`
     - `case jobEnRoute = "job_en_route"` (rename existing `driverEnRoute` to match backend category naming, OR add a new case — check which approach avoids breaking existing code)
  2. Actually, the simpler approach: keep existing enum cases but add the new category identifiers to `registerNotificationCategories()`. Add UNNotificationCategory entries for `"job_arrived"`, `"job_started"`, `"job_en_route"`, `"job_completed"` (these match the `category` field the backend will now send in push data).
  3. In `userNotificationCenter(_:didReceive:)`, add handling for the new categories:
     - If `categoryIdentifier` starts with `"job_"` and userInfo contains `"job_id"`: post NotificationCenter event `"openJobTracking"` with `job_id` in userInfo. This will allow the app to navigate to tracking view when notification is tapped.
  4. Also handle the `"job_update"` type in the fallback switch to post the same `"openJobTracking"` event.

  **Important:** Do NOT use SwiftUI `.animation()` on MapAnnotation — it doesn't work. MapKit handles annotation movement internally.
  Do NOT forget `.onDisappear` cleanup — leaving Socket.IO rooms prevents memory leaks (research pitfall 3).
  </action>
  <verify>
  Verify JobTrackingView.swift exists with Map, driver annotation, onAppear/onDisappear room management. Verify NotificationManager has categories for job_arrived, job_started, job_en_route, job_completed. Build the customer Xcode project to check for compilation errors.
  </verify>
  <done>
  Customer app has a MapKit tracking view that displays driver location as a car annotation, properly manages Socket.IO room lifecycle, and has notification categories registered for all job status transitions.
  </done>
</task>

</tasks>

<verification>
1. CustomerSocketManager.swift exists and has connect/joinJobRoom/leaveJobRoom/disconnect methods
2. Config.swift has socketURL property
3. JobTrackingView.swift shows Map with driver car annotation
4. JobTrackingView joins room on appear, leaves on disappear
5. NotificationManager registers categories for all 4 status transitions
6. Customer Xcode project compiles without errors
</verification>

<success_criteria>
- Customer can connect to Socket.IO, join a job room, and receive driver location updates
- Tracking map view displays driver position with car icon annotation
- Notification categories registered for en_route, arrived, started, completed
- Room join/leave properly managed in view lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/06-real-time-tracking/06-02-SUMMARY.md`
</output>
