---
phase: 06-real-time-tracking
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - JunkOS-Clean/JunkOS/Views/OrdersView.swift
  - JunkOS-Clean/JunkOS/Models/APIModels.swift
autonomous: true

must_haves:
  truths:
    - "Customer can tap a Track Driver button on active booking cards to open the tracking map"
    - "Track Driver button only appears when job status is en_route, arrived, or started"
    - "Booking card shows status badges for en_route (En Route), arrived (Arrived), started (In Progress)"
    - "BookingResponse model includes address field for tracking view display"
  artifacts:
    - path: "JunkOS-Clean/JunkOS/Views/OrdersView.swift"
      provides: "Track Driver button on BookingCard, NavigationLink to JobTrackingView"
      contains: "JobTrackingView"
    - path: "JunkOS-Clean/JunkOS/Models/APIModels.swift"
      provides: "address field on BookingResponse for tracking view"
      contains: "address"
  key_links:
    - from: "JunkOS-Clean/JunkOS/Views/OrdersView.swift"
      to: "JunkOS-Clean/JunkOS/Views/Tracking/JobTrackingView.swift"
      via: "NavigationLink from BookingCard to JobTrackingView"
      pattern: "JobTrackingView"
    - from: "JunkOS-Clean/JunkOS/Views/OrdersView.swift"
      to: "JunkOS-Clean/JunkOS/Services/CustomerSocketManager.swift"
      via: "Implicit dependency — JobTrackingView uses CustomerSocketManager"
      pattern: "CustomerSocketManager"
---

<objective>
Wire the tracking view into the customer booking flow so users can navigate to live tracking from their booking cards.

Purpose: TRACK-01 requires the customer to be able to see driver location when job is active. Plans 01 and 02 built the infrastructure (driver streaming + customer map). This plan connects it to the existing OrdersView/BookingCard UI so customers can actually access tracking.

Output: BookingCard shows "Track Driver" button for active jobs, navigating to JobTrackingView. Status badges updated for all active statuses.
</objective>

<execution_context>
@/Users/sevs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sevs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-real-time-tracking/06-01-SUMMARY.md
@.planning/phases/06-real-time-tracking/06-02-SUMMARY.md
@JunkOS-Clean/JunkOS/Views/OrdersView.swift
@JunkOS-Clean/JunkOS/Models/APIModels.swift
@JunkOS-Clean/JunkOS/Views/Tracking/JobTrackingView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Track Driver button to BookingCard and update status badges</name>
  <files>
    JunkOS-Clean/JunkOS/Views/OrdersView.swift
    JunkOS-Clean/JunkOS/Models/APIModels.swift
  </files>
  <action>
  **APIModels.swift** — Add `address` field to `BookingResponse`:
  1. Add `let address: String?` property to BookingResponse
  2. Add `case address` to CodingKeys enum
  3. In `init(from decoder:)`, decode: `address = try? container.decode(String.self, forKey: .address)`
  4. In `encode(to encoder:)`, add: `try container.encodeIfPresent(address, forKey: .address)`

  **OrdersView.swift** — Add tracking navigation and status badges:
  1. Wrap the existing `OrdersView` body content in a `NavigationStack` if not already wrapped (check MainTabView to see if NavigationStack is already provided — if yes, skip this step).
  2. In `BookingCard`, add a computed property `isTrackable: Bool`:
     ```swift
     private var isTrackable: Bool {
         let status = booking.status?.lowercased() ?? ""
         return ["en_route", "arrived", "started"].contains(status)
     }
     ```
  3. After the volume adjustment banner section (end of the VStack), add:
     ```swift
     if isTrackable {
         NavigationLink(destination: JobTrackingView(
             jobId: booking.bookingId,
             jobAddress: booking.address ?? "Pickup location",
             driverName: booking.driverName
         )) {
             HStack {
                 Image(systemName: "location.fill")
                 Text("Track Driver")
             }
             .font(UmuveTypography.bodyFont.weight(.semibold))
             .foregroundStyle(.white)
             .frame(maxWidth: .infinity)
             .padding(.vertical, UmuveSpacing.medium)
             .background(Color.umuvePrimary)
             .clipShape(RoundedRectangle(cornerRadius: UmuveRadius.md))
         }
     }
     ```
  4. Update the `statusBadge` computed property to handle `en_route` and `arrived` statuses with distinct labels:
     - `en_route` → ("En Route", Color.umuveInfo) — this may already be partially handled by the "In Progress" catch, but make it explicit
     - `arrived` → ("Driver Arrived", Color.umuveSuccess)
     - `started` → ("In Progress", Color.umuveInfo)
     Add these BEFORE the existing `.contains("in_progress")` check so they match first:
     ```swift
     if resolvedStatus.contains("en_route") { return ("En Route", Color.umuveInfo) }
     if resolvedStatus.contains("arrived") { return ("Driver Arrived", Color.umuveSuccess) }
     if resolvedStatus.contains("started") { return ("In Progress", Color.umuveInfo) }
     ```
  5. Add `.onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("jobStatusUpdated")))` to OrdersView to refresh bookings when a status update comes via Socket.IO:
     ```swift
     .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("jobStatusUpdated"))) { _ in
         loadBookings()
     }
     ```
  6. Also add `.onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("openJobTracking")))` listener if deep linking from push notification is desired — but this can be deferred. For now, the Track Driver button is sufficient.

  **Important:** Verify that OrdersView's parent (MainTabView) provides a NavigationStack. If not, wrap the ScrollView in NavigationStack. If MainTabView already wraps in NavigationStack, do NOT add another one (nested NavigationStacks cause bugs).
  </action>
  <verify>
  Build the customer Xcode project. Verify BookingCard shows "Track Driver" button only when status is en_route/arrived/started. Verify NavigationLink targets JobTrackingView with correct parameters. Verify status badges show "En Route", "Driver Arrived", "In Progress" for the respective statuses.
  </verify>
  <done>
  Customer sees a "Track Driver" button on active booking cards that navigates to the live tracking map view. Status badges accurately reflect en_route, arrived, and started statuses.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end verification of all TRACK requirements</name>
  <files></files>
  <action>
  Perform a code-level trace of all three TRACK requirements to verify complete implementation:

  **TRACK-01: Customer sees driver location on map when job status is en_route**
  Trace the data flow:
  1. Driver app: LocationManager.startActiveJobTracking() → didUpdateLocations → throttle check → SocketIOManager.emitLocation()
  2. Backend: socket_events.py handle_driver_location() → emit("driver:location") to job room
  3. Customer app: CustomerSocketManager listens "driver:location" → updates driverLatitude/driverLongitude → posts "driverLocationUpdated"
  4. Customer app: JobTrackingView.onReceive("driverLocationUpdated") → updates driverAnnotation → Map renders car icon
  5. Customer app: BookingCard.isTrackable → NavigationLink → JobTrackingView
  Verify: All 5 links exist in code.

  **TRACK-02: Customer receives push notifications for each job status transition**
  Trace the data flow:
  1. Driver app: ActiveJobViewModel.updateStatus() → DriverAPIClient.updateJobStatus() → PUT /api/drivers/jobs/:id/status
  2. Backend: update_job_status() → send_push_notification() for en_route, arrived, started, completed
  3. Customer app: NotificationManager receives push → categories registered for job_en_route, job_arrived, job_started, job_completed
  4. Customer app: Foreground handler shows banner, tap handler navigates via pendingDeepLink
  Verify: All 4 status transitions trigger push, categories registered.

  **TRACK-03: Driver location streams to backend via Socket.IO during active jobs**
  Trace the data flow:
  1. Driver app: ActiveJobViewModel.markEnRoute() → updateStatus("en_route") → on success → locationManager.startActiveJobTracking(jobId, contractorId)
  2. Driver app: LocationManager.didUpdateLocations → throttle (5s) → SocketIOManager.emitLocation(lat, lng, contractorId, jobId)
  3. Backend: socket_events.py handle_driver_location() → updates contractor.current_lat/lng in DB → emits to job room
  4. Driver app: ActiveJobViewModel.markCompleted() → updateStatus("completed") → on success → locationManager.stopActiveJobTracking()
  Verify: Start/stop lifecycle correct, throttling present, Socket.IO emission includes jobId.

  Report any gaps found. If all links verified, confirm phase requirements are met.
  </action>
  <verify>
  All three TRACK requirements have complete code paths from source to destination. No broken links in the data flow. Both Xcode projects should compile.
  </verify>
  <done>
  All three TRACK requirements verified: TRACK-01 (customer map shows driver), TRACK-02 (push for all status changes), TRACK-03 (driver streams GPS via Socket.IO). Phase 6 success criteria met.
  </done>
</task>

</tasks>

<verification>
1. BookingCard shows "Track Driver" button ONLY for en_route/arrived/started statuses
2. NavigationLink correctly passes jobId, address, driverName to JobTrackingView
3. Status badges show correct labels: "En Route", "Driver Arrived", "In Progress"
4. BookingResponse model has address field
5. End-to-end trace confirms all 3 TRACK requirements have complete data paths
6. Both Xcode projects compile
</verification>

<success_criteria>
- Customer can navigate from BookingCard → JobTrackingView for active jobs
- All 3 TRACK requirements verified with complete code paths
- No compilation errors in either Xcode project
</success_criteria>

<output>
After completion, create `.planning/phases/06-real-time-tracking/06-03-SUMMARY.md`
</output>
