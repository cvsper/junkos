---
phase: 04-dispatch-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/routes/booking.py
  - backend/routes/drivers.py
  - backend/socket_events.py
autonomous: true

must_haves:
  truths:
    - "When a customer creates a booking, all online approved drivers within 30km receive an APNs push notification"
    - "When a customer creates a booking, all online approved drivers within 30km receive a Socket.IO job:new event"
    - "When a driver accepts a job, the customer receives an APNs push notification"
    - "When a driver accepts a job, all other online drivers receive a Socket.IO event to remove the job from their feed"
    - "Two drivers accepting the same job simultaneously results in one success and one 409 error"
  artifacts:
    - path: "backend/routes/booking.py"
      provides: "APNs push + Socket.IO dispatch to nearby drivers on job creation"
      contains: "send_push_notification"
    - path: "backend/routes/drivers.py"
      provides: "APNs push to customer on job acceptance, broadcast to all drivers"
      contains: "send_push_notification"
    - path: "backend/socket_events.py"
      provides: "Broadcast job status to all online drivers, not just job room"
      contains: "broadcast_job_accepted"
  key_links:
    - from: "backend/routes/booking.py"
      to: "backend/socket_events.py"
      via: "notify_nearby_drivers call after job creation"
      pattern: "notify_nearby_drivers"
    - from: "backend/routes/booking.py"
      to: "backend/push_notifications.py"
      via: "send_push_notification to each nearby contractor"
      pattern: "send_push_notification"
    - from: "backend/routes/drivers.py"
      to: "backend/socket_events.py"
      via: "broadcast_job_accepted after job acceptance"
      pattern: "broadcast_job_accepted"
---

<objective>
Harden the backend dispatch pipeline so that job creation triggers both APNs push notifications AND Socket.IO events to nearby drivers, job acceptance sends APNs push to the customer, and job acceptance broadcasts removal to ALL online drivers (not just the job room).

Purpose: The backend has all the infrastructure (APNs service, Socket.IO, geospatial filtering) but the wiring is incomplete. `_notify_nearby_contractors` only creates DB records without sending APNs or Socket.IO. `accept_job` doesn't push to the customer. `broadcast_job_status` emits only to the job room, which drivers don't join.

Output: Three updated backend files with complete dispatch notification pipeline.
</objective>

<execution_context>
@/Users/sevs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sevs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/routes/booking.py
@backend/routes/drivers.py
@backend/socket_events.py
@backend/push_notifications.py
@backend/notifications.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire booking route to send APNs push + Socket.IO to nearby drivers</name>
  <files>backend/routes/booking.py</files>
  <action>
Update `_notify_nearby_contractors(job)` in booking.py to also:

1. Call `notify_nearby_drivers(job)` from `socket_events.py` to emit `job:new` Socket.IO events to nearby contractors (this function already exists and does geospatial filtering).

2. Send APNs push notification to each nearby contractor using `send_push_notification` from `notifications.py`. The push should include:
   - Title: "New Job Nearby"
   - Body: "{job.address} - ${job.total_price:.0f}"
   - Data: {"job_id": job.id, "type": "new_job", "address": job.address}

3. Keep the existing Notification DB record creation (it serves as in-app notification history).

The function already does geospatial filtering (30km radius). Add the APNs + Socket.IO calls inside the existing contractor loop.

Import `notify_nearby_drivers` from `socket_events` and `send_push_notification` from `notifications` at function scope (lazy import to avoid circular imports, matching existing pattern in drivers.py).

Note: `notify_nearby_drivers` does its own geospatial filtering, so call it ONCE outside the loop (not per-contractor). The APNs push goes inside the loop since `send_push_notification` takes a user_id.
  </action>
  <verify>
Read the updated `_notify_nearby_contractors` function and verify:
1. It calls `notify_nearby_drivers(job)` from socket_events
2. It calls `send_push_notification(contractor.user_id, ...)` for each nearby contractor
3. It still creates Notification DB records
4. No circular import issues (lazy imports inside function body)
  </verify>
  <done>When a job is created, nearby drivers receive both an APNs push notification AND a Socket.IO job:new event, in addition to the existing Notification DB record</done>
</task>

<task type="auto">
  <name>Task 2: Add customer APNs push on driver acceptance + broadcast job removal to all drivers</name>
  <files>backend/routes/drivers.py, backend/socket_events.py</files>
  <action>
**In backend/routes/drivers.py `accept_job` function:**

After the existing `db.session.commit()` and Socket.IO broadcasts, add an APNs push notification to the customer:

```python
# Send APNs push to customer
try:
    from notifications import send_push_notification
    send_push_notification(
        job.customer_id,
        "Driver Assigned",
        "A driver has been assigned to your job!",
        {"job_id": job.id, "type": "job_update", "status": "accepted"}
    )
except Exception as e:
    logger.exception("Failed to send push to customer for job %s: %s", job.id, e)
```

Also, replace the `broadcast_job_status(job.id, "accepted", ...)` call with a new function `broadcast_job_accepted(job.id, contractor.id)` that broadcasts to ALL online drivers, not just the job room. Keep the existing `socketio.emit("job:driver-assigned", ...)` call that emits to the job room for customers.

**In backend/socket_events.py:**

Add a new function `broadcast_job_accepted(job_id, driver_id)`:

```python
def broadcast_job_accepted(job_id, driver_id):
    """
    Broadcast job acceptance to ALL online approved contractors.
    Unlike broadcast_job_status (which targets the job room),
    this targets every driver room so they can remove the job from their feed.
    """
    contractors = Contractor.query.filter_by(
        is_online=True, approval_status="approved", is_operator=False
    ).all()
    payload = {"job_id": job_id, "status": "accepted", "driver_id": driver_id}
    for c in contractors:
        # Emit to each driver's personal room
        socketio.emit("job:accepted", payload, room=f"driver:{c.id}")
    # Also notify admin room
    socketio.emit("admin:job-status", payload, room="admin")
```

Use `job:accepted` as the event name (distinct from `job:status`) so the driver app can specifically handle job removal without ambiguity.

Also keep the existing `broadcast_job_status` function unchanged (it's used by other status transitions).
  </action>
  <verify>
Read the updated files and verify:
1. `accept_job` in drivers.py calls `send_push_notification` to the customer after commit
2. `accept_job` calls the new `broadcast_job_accepted` instead of `broadcast_job_status` for the driver broadcast
3. `accept_job` still emits `job:driver-assigned` to the job room for customer Socket.IO
4. `broadcast_job_accepted` in socket_events.py emits `job:accepted` to each driver's personal room (`driver:{id}`)
5. Error handling wraps the push notification in try/except (non-blocking)
  </verify>
  <done>When a driver accepts a job: customer receives APNs push notification, all online drivers receive Socket.IO event to remove the job from their feed, and the customer's job room receives driver assignment details</done>
</task>

</tasks>

<verification>
1. Read `backend/routes/booking.py` — `_notify_nearby_contractors` calls both `notify_nearby_drivers` and `send_push_notification`
2. Read `backend/routes/drivers.py` — `accept_job` sends APNs push to customer and calls `broadcast_job_accepted`
3. Read `backend/socket_events.py` — `broadcast_job_accepted` function exists and emits to each driver's personal room
4. Verify no circular imports (all cross-module imports are lazy/inside function bodies)
</verification>

<success_criteria>
- Job creation triggers APNs push + Socket.IO to nearby drivers
- Job acceptance triggers APNs push to customer
- Job acceptance broadcasts removal event to all online drivers via Socket.IO
- Race condition prevention maintained (status validation in accept_job unchanged)
- All push notifications are non-blocking (wrapped in try/except)
</success_criteria>

<output>
After completion, create `.planning/phases/04-dispatch-system/04-01-SUMMARY.md`
</output>
