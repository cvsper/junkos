---
phase: 04-dispatch-system
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - JunkOS-Clean/JunkOS/Managers/NotificationManager.swift
  - JunkOS-Clean/JunkOS/Views/OrdersView.swift
  - JunkOS-Clean/JunkOS/Services/APIClient.swift
autonomous: true

must_haves:
  truths:
    - "Customer receives a push notification when a driver is assigned to their job"
    - "Customer can see the assigned driver's name in their booking card"
    - "Customer notification includes 'driverAssigned' category for deep linking"
    - "Customer's booking list shows 'Accepted' status badge when driver accepts"
  artifacts:
    - path: "JunkOS-Clean/JunkOS/Managers/NotificationManager.swift"
      provides: "driverAssigned notification category and deep link handling"
      contains: "driverAssigned"
    - path: "JunkOS-Clean/JunkOS/Views/OrdersView.swift"
      provides: "Driver info display on booking card, auto-refresh on notification"
      contains: "driverName"
    - path: "JunkOS-Clean/JunkOS/Services/APIClient.swift"
      provides: "Job status polling endpoint"
      contains: "getJobStatus"
  key_links:
    - from: "JunkOS-Clean/JunkOS/Managers/NotificationManager.swift"
      to: "JunkOS-Clean/JunkOS/Views/OrdersView.swift"
      via: "pendingDeepLink triggers navigation to bookings"
      pattern: "driverAssigned"
    - from: "JunkOS-Clean/JunkOS/Views/OrdersView.swift"
      to: "JunkOS-Clean/JunkOS/Services/APIClient.swift"
      via: "loadBookings fetches latest status including driver assignment"
      pattern: "getCustomerBookings"
---

<objective>
Add customer-side handling for driver assignment notifications so customers know when their job has been picked up.

Purpose: The backend now sends APNs push to the customer when a driver accepts their job (Plan 01), but the customer app doesn't have the right notification category to handle it. The booking list also doesn't show driver information or the "Accepted" status. This plan closes the customer-side notification loop.

Output: Three updated Swift files in the customer app enabling driver assignment notifications and status display.
</objective>

<execution_context>
@/Users/sevs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sevs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dispatch-system/04-01-SUMMARY.md
@JunkOS-Clean/JunkOS/Managers/NotificationManager.swift
@JunkOS-Clean/JunkOS/Views/OrdersView.swift
@JunkOS-Clean/JunkOS/Services/APIClient.swift
@JunkOS-Clean/JunkOS/Views/MainTabView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add driver assignment notification category and improve booking status display</name>
  <files>
    JunkOS-Clean/JunkOS/Managers/NotificationManager.swift
    JunkOS-Clean/JunkOS/Views/OrdersView.swift
    JunkOS-Clean/JunkOS/Services/APIClient.swift
  </files>
  <action>
**1. NotificationManager.swift — Add driverAssigned notification category:**

Add `driverAssigned` to the `NotificationCategory` enum:

```swift
case driverAssigned = "driver_assigned"
```

Update the `title` computed property:
```swift
case .driverAssigned:
    return "Driver Assigned"
```

Also update `handleNotificationAction` to handle the new `type` field from push payload. The backend sends `{"type": "job_update"}` in the push data. Update the notification tap handler to also check `userInfo["type"]`:

```swift
private func handleNotificationAction(for category: NotificationCategory, userInfo: [AnyHashable: Any]) {
    DispatchQueue.main.async {
        self.pendingDeepLink = category
    }
}
```

The existing implementation already sets `pendingDeepLink` — that's fine. But the push notification from the backend sends `type: "job_update"` in the data payload, NOT as a category identifier. The current code uses `response.notification.request.content.categoryIdentifier` which won't match because the backend doesn't set `category` in the APNs payload.

Fix the `didReceive` handler to ALSO check `userInfo["type"]` as a fallback:

```swift
func userNotificationCenter(
    _ center: UNUserNotificationCenter,
    didReceive response: UNNotificationResponse,
    withCompletionHandler completionHandler: @escaping () -> Void
) {
    let categoryIdentifier = response.notification.request.content.categoryIdentifier
    let userInfo = response.notification.request.content.userInfo

    // Try category identifier first
    if let category = NotificationCategory(rawValue: categoryIdentifier) {
        handleNotificationAction(for: category, userInfo: userInfo)
    } else if let type = userInfo["type"] as? String {
        // Fallback: map backend push data "type" field to a category
        switch type {
        case "job_update":
            handleNotificationAction(for: .driverAssigned, userInfo: userInfo)
        case "new_job":
            handleNotificationAction(for: .bookingConfirmed, userInfo: userInfo)
        default:
            break
        }
    }

    completionHandler()
}
```

**2. OrdersView.swift — Add accepted/assigned status and driver info display:**

The `BookingCard` already has a `statusBadge` that handles various statuses including "assigned". It reads from `booking.status`. Add "accepted" handling to the status badge:

In the `statusBadge` computed property, add before the "assigned" check:
```swift
if resolvedStatus.contains("accepted") { return ("Driver Assigned", Color.umuveSuccess) }
```

Also add a driver name display to BookingCard. Check if `BookingResponse` has a `driverName` field. If not, add it.

Check the `BookingResponse` model — read the file to find its definition. If `driverName` is not a field, add it as an optional `String?` with a CodingKey of `driver_name`. The backend `job.to_dict()` should include `driver_name` if a driver is assigned.

Add a driver info row to BookingCard between the status badge row and the service info, shown only when a driver is assigned:

```swift
// Driver info (when assigned)
if let driverName = booking.driverName, !driverName.isEmpty {
    HStack(spacing: UmuveSpacing.small) {
        Image(systemName: "person.circle.fill")
            .font(.system(size: 14))
            .foregroundColor(.umuveSuccess)
        Text("Driver: \(driverName)")
            .font(UmuveTypography.bodySmallFont)
            .foregroundColor(.umuveText)
    }
}
```

Add auto-refresh on notification: In `OrdersView`, add an `.onReceive` for the `pendingDeepLink` publisher to reload bookings when a driver-assigned notification comes in:

```swift
.onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
    loadBookings()
}
```

This is simpler than deep linking — when the user opens the app from a push notification, the bookings list refreshes to show the updated status.

**3. APIClient.swift — Add job status endpoint (optional enhancement):**

Add a method to fetch a single job's status. This is useful if the customer taps a notification and wants to see the specific job. The backend already has `GET /api/booking/<job_id>`:

```swift
/// Get job/booking status by ID
func getJobStatus(jobId: String) async throws -> JobStatusResponse {
    let request = try createRequest(endpoint: "/api/booking/\(jobId)")
    return try await performRequest(request)
}
```

Add the response model:
```swift
struct JobStatusResponse: Codable {
    let success: Bool
    let booking: BookingStatusDetail
}

struct BookingStatusDetail: Codable {
    let id: String
    let status: String
    let address: String
    let driverName: String?
    let driverTruckType: String?
    let totalPrice: Double
    let scheduledAt: String?

    enum CodingKeys: String, CodingKey {
        case id, status, address
        case driverName = "driver_name"
        case driverTruckType = "driver_truck_type"
        case totalPrice = "total_price"
        case scheduledAt = "scheduled_at"
    }
}
```

Note: The backend's `job.to_dict()` may not include `driver_name`. Check the Job model's `to_dict()` method. If it doesn't include driver name, that's okay — the booking list refresh will still show the updated status badge. The driver name display is a best-effort enhancement.

Also ensure the `BookingResponse` model (used by OrdersView) has a `driverName` optional field. Find its definition (likely in a Models file or inline) and add `let driverName: String?` with CodingKey `driver_name` if not present. Initialize defaults for backward compatibility.
  </action>
  <verify>
1. Read NotificationManager.swift — verify `driverAssigned` case in enum and `type` fallback in didReceive
2. Read OrdersView.swift — verify "accepted" status in badge, driver name display, foreground refresh
3. Read APIClient.swift — verify `getJobStatus` method exists
4. Verify BookingResponse model has optional `driverName` field
5. Build check: `xcodebuild -project JunkOS-Clean/JunkOS.xcodeproj -scheme JunkOS -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5`
  </verify>
  <done>Customer receives push notification on driver assignment, booking list shows "Driver Assigned" status badge with driver name when applicable, and the booking list auto-refreshes when app returns to foreground</done>
</task>

</tasks>

<verification>
1. NotificationManager handles `job_update` type push notifications
2. OrdersView displays "Driver Assigned" status and driver name
3. Booking list refreshes on foreground re-entry
4. No compilation errors
</verification>

<success_criteria>
- Customer push notification for driver assignment is handled (category + tap handling)
- Booking card shows "Driver Assigned" status when job.status == "accepted"
- Driver name displays on booking card when available
- Booking list auto-refreshes on foreground entry
</success_criteria>

<output>
After completion, create `.planning/phases/04-dispatch-system/04-03-SUMMARY.md`
</output>
