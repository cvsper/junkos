---
phase: 05-volume-adjustment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/models.py
  - backend/routes/drivers.py
  - backend/routes/jobs.py
  - backend/socket_events.py
  - backend/push_notifications.py
autonomous: true

must_haves:
  truths:
    - "Backend recalculates price using driver's volume input via POST /api/drivers/jobs/<id>/volume"
    - "Customer can approve volume adjustment via POST /api/jobs/<id>/volume/approve"
    - "Customer can decline volume adjustment via POST /api/jobs/<id>/volume/decline (trip fee charged)"
    - "Stripe PaymentIntent amount updated on approval, reduced to trip fee on decline"
    - "Push notification sent to customer with VOLUME_ADJUSTMENT category containing approve/decline actions"
    - "Socket.IO events volume:approved and volume:declined emitted to driver personal room"
  artifacts:
    - path: "backend/models.py"
      provides: "Volume adjustment fields on Job model"
      contains: "volume_adjustment_proposed"
    - path: "backend/routes/drivers.py"
      provides: "POST /api/drivers/jobs/<id>/volume endpoint"
      contains: "def propose_volume_adjustment"
    - path: "backend/routes/jobs.py"
      provides: "POST /api/jobs/<id>/volume/approve and /volume/decline endpoints"
      contains: "def approve_volume_adjustment"
    - path: "backend/socket_events.py"
      provides: "volume:approved and volume:declined Socket.IO events"
      contains: "volume:approved"
    - path: "backend/push_notifications.py"
      provides: "APNs category field support in push payload"
      contains: "category"
  key_links:
    - from: "backend/routes/drivers.py"
      to: "backend/push_notifications.py"
      via: "send_push_notification with category=VOLUME_ADJUSTMENT"
      pattern: "category.*VOLUME_ADJUSTMENT"
    - from: "backend/routes/jobs.py"
      to: "backend/socket_events.py"
      via: "socketio.emit volume:approved/volume:declined to driver room"
      pattern: "volume:(approved|declined)"
    - from: "backend/routes/jobs.py"
      to: "stripe.PaymentIntent.modify"
      via: "Update PaymentIntent amount on approve or reduce to trip fee on decline"
      pattern: "PaymentIntent.modify"
---

<objective>
Add backend volume adjustment workflow: driver proposes new volume/price, customer approves or declines via push notification, Stripe PaymentIntent amount updates accordingly.

Purpose: Enables on-site price recalculation when actual junk volume differs from estimate, protecting both customer (approval required) and driver (trip fee on decline).
Output: Three new API endpoints, updated Job model, Socket.IO events, and APNs category support.
</objective>

<execution_context>
@/Users/sevs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sevs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-volume-adjustment/05-RESEARCH.md
@.planning/phases/03-payments-integration/03-02-SUMMARY.md
@.planning/phases/04-dispatch-system/04-01-SUMMARY.md

@backend/models.py
@backend/routes/drivers.py
@backend/routes/jobs.py
@backend/socket_events.py
@backend/push_notifications.py
@backend/notifications.py
@backend/routes/payments.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add volume adjustment fields to Job model and APNs category support</name>
  <files>backend/models.py, backend/push_notifications.py</files>
  <action>
  **models.py — Add 3 columns to Job model (after cancellation_fee line ~258):**
  - `volume_adjustment_proposed = Column(Boolean, default=False)` — True while waiting for customer response
  - `adjusted_volume = Column(Float, nullable=True)` — Driver's measured actual volume
  - `adjusted_price = Column(Float, nullable=True)` — Recalculated price from driver's volume

  Also add these 3 fields to Job.to_dict() method in the return dict:
  - `"volume_adjustment_proposed": self.volume_adjustment_proposed`
  - `"adjusted_volume": self.adjusted_volume`
  - `"adjusted_price": self.adjusted_price`

  **push_notifications.py — Add category support to APNs payload:**
  In the `_send_single_push` function signature (around line 100), add `category: str | None = None` parameter.
  In the aps_payload construction (around line 136), after the badge check, add:
  ```python
  if category:
      aps_payload["category"] = category
  ```

  In the `send_push_notification` function signature (around line 195), add `category: str | None = None` parameter.
  Pass `category=category` through to each `_send_single_push()` call inside the loop.

  **notifications.py — Update wrapper function:**
  In `send_push_notification` wrapper (around line 419), add `category=None` parameter. Pass it through:
  ```python
  return _send_apns(user_id, title, body, data=data, category=category)
  ```

  This requires also updating the import call inside: the push_notifications.send_push_notification already accepts `category` after the above change.
  </action>
  <verify>
  Run: `python -c "from models import Job; j = Job(); print(j.volume_adjustment_proposed, j.adjusted_volume, j.adjusted_price)"` from backend/ directory — should print `False None None`.
  Run: `python -c "from push_notifications import send_push_notification; import inspect; sig = inspect.signature(send_push_notification); print('category' in sig.parameters)"` — should print `True`.
  </verify>
  <done>Job model has volume_adjustment_proposed, adjusted_volume, adjusted_price columns exposed in to_dict(). Push notification functions accept and include category in APNs payload.</done>
</task>

<task type="auto">
  <name>Task 2: Create volume adjustment endpoints and Socket.IO events</name>
  <files>backend/routes/drivers.py, backend/routes/jobs.py, backend/socket_events.py</files>
  <action>
  **drivers.py — Add POST /api/drivers/jobs/&lt;job_id&gt;/volume endpoint:**

  Add `from routes.booking import calculate_estimate` as a lazy import inside the function body (same pattern as Phase 4 — lazy imports to avoid circular deps).

  Endpoint logic:
  1. Require auth (use existing `@require_auth` decorator)
  2. Get `actual_volume` (float) from request JSON body
  3. Validate: job exists, job.status == "arrived", requesting user is the assigned driver (check job.driver_id matches the contractor.id for user_id)
  4. Recalculate price: call `calculate_estimate` with items mapped from volume. Use the volume tier mapping from Phase 2: map actual_volume to item quantity (actual_volume <= 4 maps to quarter=2 items, <= 8 half=5, <= 12 threeQuarter=10, else full=16). Build items list: `[{"category": "general", "quantity": quantity}]`. Pass `scheduled_date=None, lat=None, lng=None` to calculate_estimate. Extract `grand_total` from result.
  5. If new price <= job.total_price: auto-approve — update job.total_price, job.volume_estimate = actual_volume, update Stripe PaymentIntent (lazy import stripe), emit socket event, return `{"success": True, "auto_approved": True, "new_price": new_price}`
  6. If new price > job.total_price: set job.volume_adjustment_proposed = True, job.adjusted_volume = actual_volume, job.adjusted_price = new_price, db.session.commit()
  7. Send push notification to customer: `send_push_notification(job.customer_id, "Price Adjustment Required", f"Volume increased. New price: ${new_price:.2f} (was ${job.total_price:.2f})", data={"job_id": job_id, "new_price": str(new_price), "original_price": str(job.total_price), "type": "volume_adjustment"}, category="VOLUME_ADJUSTMENT")` — use lazy import for notifications.send_push_notification
  8. Emit Socket.IO event: `socketio.emit("volume:proposed", {"job_id": job_id, "new_price": new_price}, room=f"driver:{job.driver_id}")` — lazy import socketio from socket_events
  9. Return `{"success": True, "new_price": new_price, "original_price": job.total_price}`

  **jobs.py — Add two endpoints:**

  **POST /api/jobs/&lt;job_id&gt;/volume/approve:**
  1. Require auth. Validate job.customer_id == user_id (403 if not)
  2. Validate job.volume_adjustment_proposed == True (409 Conflict if not — idempotency)
  3. Update Stripe PaymentIntent amount: lazy import stripe, `stripe.PaymentIntent.modify(payment.stripe_payment_intent_id, amount=int(job.adjusted_price * 100))` — only if payment and payment.stripe_payment_intent_id exist
  4. Update payment.amount = job.adjusted_price, recalculate payment.commission = job.adjusted_price * 0.20, payment.driver_payout_amount = job.adjusted_price * 0.80
  5. Update job: job.total_price = job.adjusted_price, job.volume_estimate = job.adjusted_volume, job.volume_adjustment_proposed = False
  6. db.session.commit()
  7. Emit Socket.IO: lazy import socketio, `socketio.emit("volume:approved", {"job_id": job_id}, room=f"driver:{job.driver_id}")`
  8. Return `{"success": True}`

  **POST /api/jobs/&lt;job_id&gt;/volume/decline:**
  1. Require auth. Validate job.customer_id == user_id
  2. Validate job.volume_adjustment_proposed == True (409 if not)
  3. TRIP_FEE = 50.0 (constant at top of function)
  4. Update Stripe PaymentIntent to trip fee: `stripe.PaymentIntent.modify(payment.stripe_payment_intent_id, amount=int(TRIP_FEE * 100))`
  5. Update payment.amount = TRIP_FEE, payment.commission = TRIP_FEE * 0.20, payment.driver_payout_amount = TRIP_FEE * 0.80
  6. Update job: job.status = "cancelled", job.cancelled_at = utcnow(), job.cancellation_fee = TRIP_FEE, job.volume_adjustment_proposed = False
  7. db.session.commit()
  8. Emit Socket.IO: `socketio.emit("volume:declined", {"job_id": job_id, "trip_fee": TRIP_FEE}, room=f"driver:{job.driver_id}")`
  9. Return `{"success": True, "trip_fee": TRIP_FEE}`

  All three endpoints must use try/except around Stripe calls with graceful fallback (log error but don't fail the endpoint if Stripe is unreachable in dev mode).

  **socket_events.py — No new functions needed.** The volume events are emitted directly from the route handlers using `socketio.emit()` (same pattern as Phase 4 booking.py). No new handler functions required.
  </action>
  <verify>
  Run: `python -c "from routes.drivers import drivers_bp; print([r.rule for r in drivers_bp.deferred_functions] if hasattr(drivers_bp, 'deferred_functions') else 'Blueprint registered')"` — should not error.
  Run: `python -c "from routes.jobs import jobs_bp; print('jobs_bp imported successfully')"` — should print success.
  Grep for "propose_volume_adjustment" in backend/routes/drivers.py — should find the function.
  Grep for "approve_volume_adjustment" and "decline_volume_adjustment" in backend/routes/jobs.py — should find both functions.
  </verify>
  <done>Three API endpoints operational: POST /api/drivers/jobs/&lt;id&gt;/volume (driver proposes), POST /api/jobs/&lt;id&gt;/volume/approve (customer approves), POST /api/jobs/&lt;id&gt;/volume/decline (customer declines with $50 trip fee). Stripe PaymentIntent updated on approve/decline. Socket.IO events emitted to driver room. Push notification sent to customer with VOLUME_ADJUSTMENT category.</done>
</task>

</tasks>

<verification>
1. Job model: `volume_adjustment_proposed`, `adjusted_volume`, `adjusted_price` fields exist and appear in `to_dict()`
2. Push notifications: `category` parameter flows from `notifications.send_push_notification` through to APNs payload `aps.category`
3. POST /api/drivers/jobs/<id>/volume: validates driver auth, recalculates price, sends push with category, emits socket event
4. POST /api/jobs/<id>/volume/approve: validates customer auth, updates Stripe amount, updates job price, emits volume:approved
5. POST /api/jobs/<id>/volume/decline: validates customer auth, sets trip fee on Stripe, cancels job, emits volume:declined
6. Auto-approve: price decrease skips customer notification and auto-approves
7. Idempotency: approve/decline return 409 if volume_adjustment_proposed is already False
</verification>

<success_criteria>
All backend volume adjustment logic complete: model fields, 3 endpoints, Stripe updates, push with category, Socket.IO events. Driver and customer iOS apps can call these endpoints.
</success_criteria>

<output>
After completion, create `.planning/phases/05-volume-adjustment/05-01-SUMMARY.md`
</output>
