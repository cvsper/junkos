---
phase: 05-volume-adjustment
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - JunkOS-Driver/ViewModels/VolumeAdjustmentViewModel.swift
  - JunkOS-Driver/Views/ActiveJob/VolumeAdjustmentView.swift
  - JunkOS-Driver/Views/ActiveJob/ActiveJobView.swift
  - JunkOS-Driver/Services/DriverAPIClient.swift
  - JunkOS-Driver/Services/SocketIOManager.swift
  - JunkOS-Driver/Models/JobModels.swift
autonomous: true

must_haves:
  truths:
    - "Driver can input actual volume on arrival when estimate is incorrect"
    - "Driver sees calculated new price before submitting volume adjustment"
    - "Driver sees waiting spinner after proposal, then success/failure result from customer"
    - "Volume adjustment option only appears when job status is 'arrived'"
  artifacts:
    - path: "JunkOS-Driver/ViewModels/VolumeAdjustmentViewModel.swift"
      provides: "Volume input state, API call, Socket.IO listener for approval response"
      contains: "VolumeAdjustmentViewModel"
    - path: "JunkOS-Driver/Views/ActiveJob/VolumeAdjustmentView.swift"
      provides: "Volume input UI with decimal keypad, price preview, submit button"
      contains: "VolumeAdjustmentView"
    - path: "JunkOS-Driver/Views/ActiveJob/ActiveJobView.swift"
      provides: "Navigation to VolumeAdjustmentView from arrived status"
      contains: "VolumeAdjustmentView"
    - path: "JunkOS-Driver/Services/DriverAPIClient.swift"
      provides: "proposeVolumeAdjustment API method"
      contains: "proposeVolumeAdjustment"
    - path: "JunkOS-Driver/Models/JobModels.swift"
      provides: "VolumeProposalResponse model"
      contains: "VolumeProposalResponse"
  key_links:
    - from: "JunkOS-Driver/ViewModels/VolumeAdjustmentViewModel.swift"
      to: "DriverAPIClient.shared.proposeVolumeAdjustment"
      via: "async API call to POST /api/drivers/jobs/<id>/volume"
      pattern: "proposeVolumeAdjustment"
    - from: "JunkOS-Driver/ViewModels/VolumeAdjustmentViewModel.swift"
      to: "NotificationCenter socket:volume:approved/declined"
      via: "Combine publisher subscription for Socket.IO events"
      pattern: "socket:volume:(approved|declined)"
    - from: "JunkOS-Driver/Views/ActiveJob/ActiveJobView.swift"
      to: "VolumeAdjustmentView"
      via: "Navigation from arrived status"
      pattern: "VolumeAdjustmentView"
---

<objective>
Add volume adjustment UI and logic to the driver iOS app: volume input screen, price preview, API call to propose adjustment, and real-time response handling via Socket.IO.

Purpose: Enables drivers to measure actual junk volume on arrival and propose price recalculation when it differs from the customer's estimate.
Output: New VolumeAdjustmentView + ViewModel, updated ActiveJobView with navigation, API client method, Socket.IO listener.
</objective>

<execution_context>
@/Users/sevs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sevs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-volume-adjustment/05-RESEARCH.md
@.planning/phases/05-volume-adjustment/05-01-SUMMARY.md

@JunkOS-Driver/ViewModels/ActiveJobViewModel.swift
@JunkOS-Driver/Views/ActiveJob/ActiveJobView.swift
@JunkOS-Driver/Services/DriverAPIClient.swift
@JunkOS-Driver/Services/SocketIOManager.swift
@JunkOS-Driver/Models/JobModels.swift
@JunkOS-Driver/Design/DriverDesignSystem.swift
@JunkOS-Driver/Utilities/HapticManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add API method and response models for volume adjustment</name>
  <files>JunkOS-Driver/Services/DriverAPIClient.swift, JunkOS-Driver/Models/JobModels.swift, JunkOS-Driver/Services/SocketIOManager.swift</files>
  <action>
  **JobModels.swift — Add response model at the end of the file:**
  ```swift
  // MARK: - Volume Adjustment

  struct VolumeProposalResponse: Codable {
      let success: Bool
      let newPrice: Double?
      let originalPrice: Double?
      let autoApproved: Bool?

      enum CodingKeys: String, CodingKey {
          case success
          case newPrice = "new_price"
          case originalPrice = "original_price"
          case autoApproved = "auto_approved"
      }
  }
  ```

  **DriverAPIClient.swift — Add volume adjustment API method:**
  Add inside the actor, after existing methods:
  ```swift
  // MARK: - Volume Adjustment

  func proposeVolumeAdjustment(jobId: String, actualVolume: Double) async throws -> VolumeProposalResponse {
      struct Body: Encodable {
          let actual_volume: Double
      }
      return try await request(
          "/api/drivers/jobs/\(jobId)/volume",
          method: "POST",
          body: Body(actual_volume: actualVolume)
      )
  }
  ```

  **SocketIOManager.swift — Add volume event listeners:**
  In the `setupEventListeners()` method (or equivalent), add listeners for `volume:approved` and `volume:declined` events. When received, post to NotificationCenter:
  ```swift
  socket.on("volume:approved") { data, _ in
      NotificationCenter.default.post(
          name: NSNotification.Name("socket:volume:approved"),
          object: nil,
          userInfo: data.first as? [String: Any]
      )
  }

  socket.on("volume:declined") { data, _ in
      NotificationCenter.default.post(
          name: NSNotification.Name("socket:volume:declined"),
          object: nil,
          userInfo: data.first as? [String: Any]
      )
  }
  ```
  This follows the exact same NotificationCenter bridge pattern used in Phase 4 for job:new and job:accepted events.
  </action>
  <verify>Grep for "proposeVolumeAdjustment" in DriverAPIClient.swift — should find the method. Grep for "VolumeProposalResponse" in JobModels.swift — should find the struct. Grep for "volume:approved" in SocketIOManager.swift — should find the listener.</verify>
  <done>DriverAPIClient has proposeVolumeAdjustment method, JobModels has VolumeProposalResponse, SocketIOManager bridges volume:approved and volume:declined to NotificationCenter.</done>
</task>

<task type="auto">
  <name>Task 2: Create VolumeAdjustmentView and ViewModel with ActiveJobView integration</name>
  <files>JunkOS-Driver/ViewModels/VolumeAdjustmentViewModel.swift, JunkOS-Driver/Views/ActiveJob/VolumeAdjustmentView.swift, JunkOS-Driver/Views/ActiveJob/ActiveJobView.swift</files>
  <action>
  **VolumeAdjustmentViewModel.swift — Create new file:**
  Use `@Observable` pattern (same as ActiveJobViewModel). Properties:
  - `var volumeInput: String = ""` — raw text input for volume
  - `var isSubmitting = false`
  - `var isWaitingForApproval = false`
  - `var wasApproved: Bool? = nil` — nil = pending, true = approved, false = declined
  - `var autoApproved = false` — true when price decreased and was auto-approved
  - `var newPrice: Double? = nil`
  - `var originalPrice: Double? = nil`
  - `var errorMessage: String? = nil`
  - `var tripFee: Double? = nil` — set on decline
  - `private var cancellables = Set<AnyCancellable>()` (import Combine)
  - `private let api = DriverAPIClient.shared`

  In init(), subscribe to NotificationCenter publishers (same Combine pattern as Phase 4):
  ```swift
  NotificationCenter.default.publisher(for: NSNotification.Name("socket:volume:approved"))
      .receive(on: RunLoop.main)
      .sink { [weak self] _ in
          self?.wasApproved = true
          self?.isWaitingForApproval = false
          HapticManager.shared.success()
      }
      .store(in: &cancellables)

  NotificationCenter.default.publisher(for: NSNotification.Name("socket:volume:declined"))
      .receive(on: RunLoop.main)
      .sink { [weak self] notification in
          self?.wasApproved = false
          self?.isWaitingForApproval = false
          self?.tripFee = (notification.userInfo?["trip_fee"] as? NSNumber)?.doubleValue ?? 50.0
          HapticManager.shared.error()
      }
      .store(in: &cancellables)
  ```

  Add `var parsedVolume: Double?` computed property: `Double(volumeInput)`

  Add `var isValid: Bool` computed property: `parsedVolume != nil && (parsedVolume ?? 0) > 0`

  Add async method `func proposeAdjustment(jobId: String)`:
  1. Guard isValid, set isSubmitting = true, errorMessage = nil
  2. `let response = try await api.proposeVolumeAdjustment(jobId: jobId, actualVolume: parsedVolume!)`
  3. Set newPrice = response.newPrice, originalPrice = response.originalPrice
  4. If response.autoApproved == true: set autoApproved = true, wasApproved = true, HapticManager.shared.success()
  5. Else: set isWaitingForApproval = true
  6. Catch: set errorMessage, HapticManager.shared.error()
  7. Always: isSubmitting = false

  **VolumeAdjustmentView.swift — Create new file:**
  SwiftUI View with:
  - Takes `jobId: String` and `originalEstimate: Double?` as params, plus `@State private var viewModel = VolumeAdjustmentViewModel()`
  - Background: Color.driverBackground
  - ScrollView content:
    1. Header section: "Adjust Volume" title, subtitle "Enter the actual volume measured on-site"
    2. Current estimate display card (if originalEstimate exists): "Original Estimate: X cu yd"
    3. Volume input: TextField "Actual volume (cu yd)" with `.keyboardType(.decimalPad)`, bound to viewModel.volumeInput. Add onChange filter allowing only digits and single decimal point (max 1 decimal place).
    4. If viewModel.newPrice != nil: price comparison card showing original price and new price with arrow between them
    5. Submit button: "Submit Adjustment" — disabled when !viewModel.isValid or viewModel.isSubmitting. On tap: `Task { await viewModel.proposeAdjustment(jobId: jobId) }`
    6. If viewModel.isWaitingForApproval: overlay with ProgressView + "Waiting for customer approval..." text
    7. If viewModel.wasApproved == true: success overlay with checkmark.circle.fill icon, "Customer Approved" (or "Auto-Approved — Price Decreased" if autoApproved), green accent
    8. If viewModel.wasApproved == false: decline overlay with xmark.circle.fill icon, "Customer Declined", "Trip fee: $XX.XX" if tripFee set, red accent
    9. Error text if viewModel.errorMessage set

  Use DriverDesignSystem colors (Color.driverPrimary, Color.driverBackground, etc.) and typography (DriverTypography). Use DriverSpacing for padding.

  **ActiveJobView.swift — Add navigation to VolumeAdjustmentView:**
  In the `.arrived` case of the switch statement (currently shows `BeforePhotosView`), wrap the existing content in a VStack and add a button below BeforePhotosView:
  ```swift
  case .arrived:
      VStack(spacing: DriverSpacing.md) {
          BeforePhotosView(viewModel: viewModel)

          NavigationLink(destination: VolumeAdjustmentView(
              jobId: job.id,
              originalEstimate: job.volumeEstimate
          )) {
              Label("Adjust Volume", systemImage: "arrow.up.arrow.down.circle")
                  .font(DriverTypography.body)
                  .foregroundStyle(Color.driverPrimary)
                  .frame(maxWidth: .infinity)
                  .padding(DriverSpacing.md)
                  .background(Color.driverPrimary.opacity(0.1))
                  .clipShape(RoundedRectangle(cornerRadius: 12))
          }
          .padding(.horizontal, DriverSpacing.xl)
      }
  ```
  Make sure ActiveJobView is inside a NavigationStack (check if it already is — if not, wrap the body in one). The existing ActiveJobView should already be within a navigation context from DriverTabView.
  </action>
  <verify>Grep for "VolumeAdjustmentViewModel" in VolumeAdjustmentViewModel.swift — should find the class. Grep for "VolumeAdjustmentView" in VolumeAdjustmentView.swift and ActiveJobView.swift — should find in both. Verify no SwiftUI syntax errors by checking balanced braces.</verify>
  <done>Driver app has VolumeAdjustmentView with decimal input, price preview, and submit button. ActiveJobView shows "Adjust Volume" button when job status is arrived. ViewModel handles API call and listens for Socket.IO approval/decline events via NotificationCenter bridge.</done>
</task>

</tasks>

<verification>
1. VolumeAdjustmentView renders: volume input field with decimal keypad, submit button, and status overlays
2. ActiveJobView shows "Adjust Volume" NavigationLink when job status is .arrived
3. proposeVolumeAdjustment API method sends POST to /api/drivers/jobs/<id>/volume
4. Socket.IO volume:approved and volume:declined events bridge to NotificationCenter and update ViewModel
5. Auto-approve case (price decrease) shows immediate success without waiting
6. Decline case shows trip fee amount
</verification>

<success_criteria>
Driver can navigate to volume adjustment screen from active job, input actual volume with decimal keyboard, see calculated price, submit proposal, and see real-time approval/decline response from customer via Socket.IO.
</success_criteria>

<output>
After completion, create `.planning/phases/05-volume-adjustment/05-02-SUMMARY.md`
</output>
