---
phase: 02-pricing-booking
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - JunkOS-Clean/JunkOS/Views/PhotoUploadView.swift
  - JunkOS-Clean/JunkOS/ViewModels/PhotoUploadViewModel.swift
  - JunkOS-Clean/JunkOS/Views/DateTimePickerView.swift
  - JunkOS-Clean/JunkOS/ViewModels/DateTimePickerViewModel.swift
  - JunkOS-Clean/JunkOS/Views/BookingWizardView.swift
  - JunkOS-Clean/JunkOS/Services/APIClient.swift
autonomous: true

must_haves:
  truths:
    - "Customer can select photos from gallery or camera (max 10)"
    - "Photos display in a grid preview with delete capability"
    - "Customer can select date and time slot for pickup"
    - "Running price estimate updates after photos and scheduling steps"
    - "Photo step plugs into BookingWizardView as step 2"
    - "Schedule step plugs into BookingWizardView as step 3"
    - "APIClient can call backend pricing estimate endpoint"
  artifacts:
    - path: "JunkOS-Clean/JunkOS/Views/PhotoUploadView.swift"
      provides: "Photo upload step for wizard"
      contains: "PhotoUploadView"
    - path: "JunkOS-Clean/JunkOS/Views/DateTimePickerView.swift"
      provides: "Schedule selection step for wizard"
      contains: "DateTimePickerView"
    - path: "JunkOS-Clean/JunkOS/Services/APIClient.swift"
      provides: "Pricing estimate API method"
      contains: "getPricingEstimate"
  key_links:
    - from: "JunkOS-Clean/JunkOS/Views/BookingWizardView.swift"
      to: "JunkOS-Clean/JunkOS/Views/PhotoUploadView.swift"
      via: "step 2 in wizard switch"
      pattern: "PhotoUploadView"
    - from: "JunkOS-Clean/JunkOS/Views/BookingWizardView.swift"
      to: "JunkOS-Clean/JunkOS/Views/DateTimePickerView.swift"
      via: "step 3 in wizard switch"
      pattern: "DateTimePickerView"
    - from: "JunkOS-Clean/JunkOS/Services/APIClient.swift"
      to: "backend /api/pricing/estimate"
      via: "HTTP POST"
      pattern: "pricing/estimate"
---

<objective>
Adapt PhotoUploadView and DateTimePickerView for the wizard pattern, add backend pricing estimate API integration, and wire as steps 2 and 3 in the booking wizard. The running price estimate bar updates after these steps.

Purpose: Photos help with accurate pricing (optional but encouraged). Schedule selection determines time-based surcharges. The pricing API integration enables the running price estimate that updates as the customer progresses through the wizard.
Output: Refactored PhotoUploadView, refactored DateTimePickerView, pricing API method in APIClient, wired as steps 2 and 3.
</objective>

<execution_context>
@/Users/sevs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sevs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-pricing-booking/02-CONTEXT.md
@.planning/phases/02-pricing-booking/02-RESEARCH.md
@.planning/phases/02-pricing-booking/02-01-SUMMARY.md
@.planning/phases/02-pricing-booking/02-02-SUMMARY.md
@.planning/phases/02-pricing-booking/02-03-SUMMARY.md
@JunkOS-Clean/JunkOS/Views/PhotoUploadView.swift
@JunkOS-Clean/JunkOS/Views/DateTimePickerView.swift
@JunkOS-Clean/JunkOS/Services/APIClient.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Adapt PhotoUploadView and DateTimePickerView for wizard pattern</name>
  <files>JunkOS-Clean/JunkOS/Views/PhotoUploadView.swift, JunkOS-Clean/JunkOS/ViewModels/PhotoUploadViewModel.swift, JunkOS-Clean/JunkOS/Views/DateTimePickerView.swift, JunkOS-Clean/JunkOS/ViewModels/DateTimePickerViewModel.swift</files>
  <action>
**Refactor PhotoUploadView.swift (Step 2):**

The existing PhotoUploadView is mostly good — it already has PhotosPicker, camera, grid preview, and delete. Key changes needed:

1. Remove the NavigationLink-based Continue button. Replace with a plain Button that calls `wizardVM.completeCurrentStep()` via `@EnvironmentObject var wizardVM: BookingWizardViewModel`.

2. Remove the `ScreenHeader` progress bar (wizard handles progress indicator). Keep the title "Take Photos" and subtitle.

3. Photos are optional but encouraged (Claude's discretion). The continue button should always be enabled (no photos required). Show an encouragement message when no photos: "Photos help us provide accurate pricing. You can skip this step, but we recommend at least 1 photo."

4. Keep max 10 photos (per user decision).

5. Keep existing photo grid, camera picker, gallery picker, tip box.

6. Remove any NavigationLink to DateTimePickerView from the Continue button — wizard handles navigation.

**Refactor DateTimePickerView.swift (Step 3):**

Similar changes to adapt for wizard:

1. Remove NavigationLink-based Continue button. Replace with Button calling `wizardVM.completeCurrentStep()`.

2. Remove `ScreenHeader` progress bar. Keep title "Choose Date & Time".

3. Remove NavigationLink to ConfirmationView from Continue button.

4. Remove `BookingSummaryPreview` section — the wizard has its own running price estimate bar.

5. Keep date selector (horizontal scroll of date cards) and time slot section (vertical list).

6. Continue button enabled only when both date and time are selected (`viewModel.hasSelectedDateTime`).

7. Add `@EnvironmentObject var wizardVM: BookingWizardViewModel`.

**For both views:** Ensure they still work with `@EnvironmentObject var bookingData: BookingData` (no changes to data binding).
  </action>
  <verify>
Build the project. Both views compile without NavigationLink-based navigation. Continue buttons call wizardVM.completeCurrentStep(). No ScreenHeader progress bars in either view.
  </verify>
  <done>
PhotoUploadView adapted for wizard (photos optional, Continue calls wizardVM). DateTimePickerView adapted for wizard (Continue calls wizardVM, no NavigationLink). Both compile and work with BookingData via EnvironmentObject.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pricing estimate API to APIClient and wire steps 2-3 into wizard with running price</name>
  <files>JunkOS-Clean/JunkOS/Services/APIClient.swift, JunkOS-Clean/JunkOS/Views/BookingWizardView.swift</files>
  <action>
**Add pricing estimate method to APIClient.swift:**

Add a new public method:
```swift
func getPricingEstimate(
    serviceType: String,
    volumeTier: String?,
    vehicleInfo: [String: Any]?,
    pickupLat: Double?,
    pickupLng: Double?,
    dropoffLat: Double?,
    dropoffLng: Double?,
    scheduledDate: String?
) async throws -> PricingEstimate
```

Implementation:
- Build request body as `[String: Any]` dictionary
- For Junk Removal: map volumeTier to items array. Example: "1/2 Truck" maps to `[{"category": "general", "quantity": 5, "size": "medium"}]` (approximation — the backend's item-based pricing will estimate from this)
  - quarter: quantity 2
  - half: quantity 5
  - threeQuarter: quantity 10
  - full: quantity 16
- For Auto Transport: include `vehicleInfo` dict with make/model/year and surcharges
- Include address coordinates: `{"lat": pickupLat, "lng": pickupLng}`
- Include scheduledDate if available
- POST to `/api/pricing/estimate`
- Decode response into `PricingEstimate` struct

Handle the backend response format:
```json
{
  "success": true,
  "estimate": {
    "subtotal": 240.00,
    "service_fee": 19.20,
    "volume_discount": -24.00,
    "time_surge": 0.00,
    "zone_surge": 0.00,
    "total": 235.20,
    "estimated_duration_minutes": 46,
    "recommended_truck": "Standard Pickup"
  }
}
```

Use snake_case to camelCase key decoding strategy on JSONDecoder, or define CodingKeys on PricingEstimate.

**Update BookingWizardView.swift:**

1. Replace step 2 placeholder with `PhotoUploadView().environmentObject(bookingData).environmentObject(wizardVM)`
2. Replace step 3 placeholder with `DateTimePickerView().environmentObject(bookingData).environmentObject(wizardVM)`

3. Add pricing refresh logic: When `wizardVM.currentStep` changes (via .onChange), call the pricing API if we have enough data:
   - After step 0 (service selected): call pricing with serviceType + volumeTier (no address yet)
   - After step 1 (address entered): call pricing with serviceType + volumeTier + coordinates
   - After step 3 (schedule selected): call pricing with all data including scheduledDate

   Use a method on BookingWizardViewModel:
   ```swift
   func refreshPricing(bookingData: BookingData) async {
       // Only call API if we have at least service type
       guard let serviceType = bookingData.serviceType else { return }
       do {
           let estimate = try await APIClient.shared.getPricingEstimate(...)
           await MainActor.run {
               bookingData.estimatedPrice = estimate.total
               bookingData.priceBreakdown = estimate
           }
       } catch {
           print("[pricing] Error: \(error)")
           // Don't show error to user — pricing updates are best-effort
       }
   }
   ```

4. Update the running price estimate bar at the bottom of BookingWizardView:
   - Shows when `bookingData.estimatedPrice` is not nil
   - Format: "Est. $XXX.XX" in large bold text
   - Tap to expand: shows line items from `bookingData.priceBreakdown` (subtotal, service fee, discounts, surge, total)
   - Collapse by tapping again
   - Use `@State var isPriceExpanded = false`
  </action>
  <verify>
Build the project. Verify:
1. APIClient has `getPricingEstimate` method
2. PhotoUploadView wired as step 2 in wizard
3. DateTimePickerView wired as step 3 in wizard
4. Running price bar appears after service selection
5. Price updates when step changes (pricing API called)
6. Price bar is expandable to show breakdown
  </verify>
  <done>
APIClient has getPricingEstimate method that POSTs to /api/pricing/estimate and decodes PricingEstimate. PhotoUploadView is step 2, DateTimePickerView is step 3 in wizard. Running price estimate bar updates as customer progresses. Price bar is expandable for line-item breakdown. Project compiles.
  </done>
</task>

</tasks>

<verification>
- PhotoUploadView adapted for wizard (no NavigationLink, calls wizardVM)
- DateTimePickerView adapted for wizard (no NavigationLink, calls wizardVM)
- APIClient.getPricingEstimate calls /api/pricing/estimate and returns PricingEstimate
- Steps 2 and 3 wired in BookingWizardView
- Running price bar appears and updates after each step with expandable breakdown
- Project compiles: `xcodebuild build` succeeds
</verification>

<success_criteria>
Customer can upload photos (optional), select schedule, and see running price estimate that updates after each step. The pricing API integration provides real estimates from the backend.
</success_criteria>

<output>
After completion, create `.planning/phases/02-pricing-booking/02-04-SUMMARY.md`
</output>
